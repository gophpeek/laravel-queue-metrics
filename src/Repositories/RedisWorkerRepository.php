<?php

declare(strict_types=1);

namespace PHPeek\LaravelQueueMetrics\Repositories;

use Carbon\Carbon;
use PHPeek\LaravelQueueMetrics\DataTransferObjects\WorkerStatsData;
use PHPeek\LaravelQueueMetrics\Repositories\Contracts\WorkerRepository;
use PHPeek\LaravelQueueMetrics\Support\RedisMetricsStore;

/**
 * Redis-based implementation of worker repository.
 */
final readonly class RedisWorkerRepository implements WorkerRepository
{
    public function __construct(
        private RedisMetricsStore $redis,
    ) {}

    public function registerWorker(
        int $pid,
        string $hostname,
        string $connection,
        string $queue,
        Carbon $spawnedAt,
    ): void {
        $key = $this->redis->key('worker', $hostname, (string) $pid);
        $driver = $this->redis->driver();
        $ttl = $this->redis->getTtl('raw');

        $driver->setHash($key, [
            'pid' => $pid,
            'hostname' => $hostname,
            'connection' => $connection,
            'queue' => $queue,
            'status' => 'idle',
            'jobs_processed' => 0,
            'spawned_at' => $spawnedAt->timestamp,
            'last_activity' => Carbon::now()->timestamp,
        ]);

        // Add to active workers set with hostname:pid format
        $activeWorkersKey = $this->redis->key('active_workers');
        $driver->addToSet($activeWorkersKey, [$hostname.':'.$pid]);

        // Set TTL on both keys
        $driver->expire($key, $ttl);
        $driver->expire($activeWorkersKey, $ttl);
    }

    public function updateWorkerActivity(
        int $pid,
        string $hostname,
        string $status,
        ?string $currentJob = null,
        int $jobsProcessed = 0,
        float $idlePercentage = 0.0,
    ): void {
        $key = $this->redis->key('worker', $hostname, (string) $pid);
        $driver = $this->redis->driver();
        $ttl = $this->redis->getTtl('raw');

        $updates = [
            'status' => $status,
            'last_activity' => Carbon::now()->timestamp,
        ];

        if ($currentJob !== null) {
            $updates['current_job'] = $currentJob;
        }

        if ($jobsProcessed > 0) {
            $driver->incrementHashField($key, 'jobs_processed', $jobsProcessed);
        }

        if ($idlePercentage > 0.0) {
            $updates['idle_percentage'] = (string) $idlePercentage;
        }

        $driver->setHash($key, $updates);

        // Refresh TTL on update
        $driver->expire($key, $ttl);
    }

    public function unregisterWorker(int $pid, string $hostname): void
    {
        $key = $this->redis->key('worker', $hostname, (string) $pid);
        $driver = $this->redis->driver();

        $driver->delete($key);
        $driver->removeFromSet($this->redis->key('active_workers'), [$hostname.':'.$pid]);
    }

    public function getWorkerStats(int $pid, string $hostname): ?WorkerStatsData
    {
        // Workers are stored by workerId (generated by HorizonDetector)
        // We need to scan workers:all to find workers by hostname/pid
        $indexKey = $this->redis->key('workers', 'all');
        $driver = $this->redis->driver();

        /** @var array<string> */
        $workerIds = $driver->getSortedSetByRank($indexKey, 0, -1);

        // Find worker by matching hostname and pid
        foreach ($workerIds as $workerId) {
            $workerKey = $this->redis->key('worker', $workerId);
            /** @var array<string, string> */
            $data = $driver->getHash($workerKey) ?: [];

            if (empty($data)) {
                continue;
            }

            // Match by hostname and pid
            if (($data['hostname'] ?? '') === $hostname && (int) ($data['pid'] ?? 0) === $pid) {
                // Detect Horizon worker from worker_id
                $workerId = $data['worker_id'] ?? '';
                $isHorizon = str_contains($workerId, 'worker_horizon_');

                return WorkerStatsData::fromArray([
                    'pid' => (int) $data['pid'],
                    'hostname' => $data['hostname'] ?? 'unknown',
                    'connection' => $data['connection'] ?? 'default',
                    'queue' => $data['queue'] ?? 'default',
                    'status' => $data['state'] ?? 'idle',
                    'jobs_processed' => (int) ($data['jobs_processed'] ?? 0),
                    'current_job' => $data['current_job_class'] ?? null,
                    'idle_percentage' => (float) ($data['idle_percentage'] ?? 0.0),
                    'spawned_at' => isset($data['spawned_at'])
                        ? Carbon::createFromTimestamp((int) $data['spawned_at'])->toIso8601String()
                        : null,
                    'last_heartbeat' => $data['last_heartbeat'] ?? null,
                    'is_horizon_worker' => $isHorizon,
                ]);
            }
        }

        return null;
    }

    /**
     * @return array<int, WorkerStatsData>
     */
    public function getActiveWorkers(?string $connection = null, ?string $queue = null): array
    {
        $driver = $this->redis->driver();
        $indexKey = $this->redis->key('workers', 'all');

        // Get all worker IDs from sorted set
        /** @var array<string> */
        $workerIds = $driver->getSortedSetByRank($indexKey, 0, -1);

        $workers = [];
        foreach ($workerIds as $workerId) {
            $workerKey = $this->redis->key('worker', $workerId);
            /** @var array<string, string> */
            $data = $driver->getHash($workerKey) ?: [];

            if (empty($data)) {
                continue;
            }

            // Skip workers that are stopped, crashed, or unknown
            $state = $data['state'] ?? 'unknown';
            if (! in_array($state, ['idle', 'busy', 'paused'], true)) {
                continue;
            }

            // Skip sync workers - they are not real persistent workers
            $workerConnection = $data['connection'] ?? 'unknown';
            if ($workerConnection === 'sync') {
                continue;
            }

            // Detect Horizon worker from worker_id format: worker_horizon_supervisor_hostname_pid
            $workerId = $data['worker_id'] ?? '';
            $isHorizon = str_contains($workerId, 'worker_horizon_');

            // Convert to WorkerStatsData
            $stats = WorkerStatsData::fromArray([
                'pid' => (int) ($data['pid'] ?? 0),
                'hostname' => $data['hostname'] ?? 'unknown',
                'connection' => $data['connection'] ?? 'default',
                'queue' => $data['queue'] ?? 'default',
                'status' => $state,
                'jobs_processed' => (int) ($data['jobs_processed'] ?? 0),
                'current_job' => $data['current_job_class'] ?? null,
                'idle_percentage' => (float) ($data['idle_percentage'] ?? 0.0),
                'spawned_at' => isset($data['spawned_at'])
                    ? Carbon::createFromTimestamp((int) $data['spawned_at'])->toIso8601String()
                    : null,
                'last_heartbeat' => $data['last_heartbeat'] ?? null,
                'is_horizon_worker' => $isHorizon,
            ]);

            // Filter by connection/queue if specified
            if ($connection !== null && $stats->connection !== $connection) {
                continue;
            }

            if ($queue !== null && $stats->queue !== $queue) {
                continue;
            }

            $workers[] = $stats;
        }

        return $workers;
    }

    public function countActiveWorkers(string $connection, string $queue): int
    {
        $workers = $this->getActiveWorkers($connection, $queue);

        return count($workers);
    }

    public function cleanupStaleWorkers(int $olderThanSeconds): int
    {
        $driver = $this->redis->driver();
        $indexKey = $this->redis->key('workers', 'all');

        // Calculate cutoff timestamp
        $cutoff = Carbon::now()->subSeconds($olderThanSeconds)->timestamp;

        // Get workers with stale heartbeats using ZSET score (timestamp)
        /** @var array<string> */
        $staleWorkerIds = $driver->getSortedSetByScore($indexKey, '-inf', (string) $cutoff);

        $deleted = 0;

        foreach ($staleWorkerIds as $workerId) {
            $workerKey = $this->redis->key('worker', $workerId);

            // Delete worker hash and remove from index
            $driver->delete($workerKey);
            $driver->removeFromSortedSet($indexKey, $workerId);
            $deleted++;
        }

        return $deleted;
    }
}
